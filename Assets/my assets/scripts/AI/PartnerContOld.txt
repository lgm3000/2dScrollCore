//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.42000
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using UnityEngine;

namespace UnityStandardAssets._2D
{
	public class PartnerContOld : MonoBehaviour
	{
		[SerializeField] private LayerMask m_WhatIsGround;
		//		public GameObject player;
		
		private float m_MaxSpeed = 10f;
		
		
		
		private Transform playerTrans;
		private Rigidbody2D m_Rigidbody2D;
		private int moveMode;			//movemode: 0:comfortable 1:follow 2:chase 3:deccelerate 4:teleport
		private Animator m_Anim;
		private bool m_FacingRight = true;
		private int timer;
		private CircleCollider2D m_feet;
		private Vector2 m_force;
		
		private void Awake()
		{
			m_Rigidbody2D = GetComponent<Rigidbody2D> ();
			m_Anim = GetComponent<Animator>();
			m_feet = GetComponent<CircleCollider2D> ();
			playerTrans = GameObject.FindGameObjectWithTag ("Player").transform;
			//			playerTrans = player.transform;
			timer = 0;
			
		}
		
		private void FixedUpdate()
		{
			switch(moveMode){
			case 0:
				m_Rigidbody2D.velocity = new Vector2(0,m_Rigidbody2D.velocity.y);
				break;
			case 1:
				m_Rigidbody2D.velocity = new Vector2((playerTrans.position.x - m_Rigidbody2D.position.x)*1.2f,m_Rigidbody2D.velocity.y);
				break;
			case 2:
				Move ();
				break;
			case 3:
				Move();
				break;
			}
			if (m_Rigidbody2D.velocity.x > 0 && !m_FacingRight) {
				// ... flip the player.
				Flip ();
			}
			// Otherwise if the input is moving the player left and the player is facing right...
			else if (m_Rigidbody2D.velocity.x < 0 && m_FacingRight) {
				// ... flip the player.
				Flip ();
			}
		}
		
		private void Move()
		{
			
			m_Rigidbody2D.AddForce(m_force);
			if (m_Rigidbody2D.velocity.x < 0 && -m_Rigidbody2D.velocity.x > m_MaxSpeed)
				m_Rigidbody2D.velocity = new Vector2 (-m_MaxSpeed,m_Rigidbody2D.velocity.y);
			if (m_Rigidbody2D.velocity.x > 0 && m_Rigidbody2D.velocity.x > m_MaxSpeed)
				m_Rigidbody2D.velocity = new Vector2 (m_MaxSpeed,m_Rigidbody2D.velocity.y);
			//m_Rigidbody2D.velocity = new Vector2 (Mathf.Abs(m_Rigidbody2D.velocity.x) > Math.Abs(m_MaxSpeed) ? m_MaxSpeed:m_Rigidbody2D.velocity.x,m_Rigidbody2D.velocity.y);
		}
		private void Flip()
		{
			// Switch the way the player is labelled as facing.
			m_FacingRight = !m_FacingRight;
			
			// Multiply the player's x local scale by -1.
			Vector3 theScale = transform.localScale;
			theScale.x *= -1;
			transform.localScale = theScale;
		}
		
		
		public void OnMyTriggerEnter(int t)
		{
			if (t == 1) {
				moveMode = 0;
			}
			if (t == 2) 
			{
				m_force = new Vector2((playerTrans.position.x - m_Rigidbody2D.transform.position.x)*200,0);
				moveMode = 3;
			}
		}
		public void OnMyTriggerExit(int t)
		{
			if (t == 1)
				moveMode = 1;
			if (t == 2) 
			{
				m_force = new Vector2 (((playerTrans.position.x - m_Rigidbody2D.transform.position.x) > 1 ? 10 : -10), 0);
				moveMode = 2;
			}
			if (t == 3)
				moveMode = 4;
		}
		
	}
	
}
